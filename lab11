# Дао Ань Туан ИУ7-14Б, лаб. 11, метод левых треугольников и параболы 
import math

def f(x):
    '''Считает значение функции
    args:
        x(float): точка '''
    return (x)**2

def g(x):
    return -(x)**2 + 10

def h(x):
    return f(x) - g(x)

def bisection(a, b, eps=1e-8):
    fa, fb = h(a), h(b)

    if fa * fb > 0:
        return None

    while b - a > eps:
        c = (a + b) / 2
        fc = h(c)

        if abs(fc) < eps:
            return c

        if fa * fc < 0:
            b = c
            fb = fc
        else:
            a = c
            fa = fc

    return (a + b) / 2

def antiderivative(x1, x2):
    '''Считает значение первообразной
    args:
        x1(float): 1-ая точка
        x2(float): 2-ая точка
    return:
        value(float): значение первообразной
        None(NoneType): если возникает ошибка при вычислении
    '''
    try:
        #value = math.log(x2, math.e) - math.log(x1, math.e)
        value = (1/3 * (x2 - 15)**3 - 100 * x2) - (1/3 * (x1 - 15)**3 - 100 * x1)
        return abs(value)
    except (ValueError, ZeroDivisionError):
        print('Ошибка, невозможно вычислить значение первообразной в заданном интервале, интеграл не существует')
        return None

def left_rule(f, x1, x2, n):
    '''Находит интеграл по методу левых треугольников
    args:
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        n(int): кол-во участков разбиения
    return:
        result(float): значение интеграла
        None(NoneType): если интеграл не существует
    '''
    try:
        result = 0
        if n != 0:
            delta_x = (x2 - x1) / n
            for i in range(n):
                result += f(x1 + i * delta_x) * delta_x
                # слишком большая величина => разрыв / асимптота
                if not math.isfinite(result):
                    return None
                
                
        return result
        
    except (ZeroDivisionError, ValueError, OverflowError):
        return None

def simpsons_rule(f, x1, x2, n):
    '''Находит интеграл по методу парабол
    args:
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        n(int): кол-во участков разбиения
    return:
        result(float): значение интеграла
        None(NoneType): если интеграл не существует
    '''
    try:
        result = 0
        if n != 0:
            delta_x = (x2 - x1) / n
            for i in range(n):
                y1 = f(x1 + i * delta_x)
                y2 = f(x1 + (i + 0.5) * delta_x)
                y3 = f(x1 + (i + 1) * delta_x)

                if not (math.isfinite(y1) and math.isfinite(y2) and math.isfinite(y3)):
                    return None
                result += (y1 + 4 * y2 + y3) * delta_x / 6
                
        return abs(result)
        
    except (ZeroDivisionError, ValueError, OverflowError):
        return None

def calculate_errors(approximate, exact):
    '''Вычисление абсолютной и относительной погрешностей
    args:
        approximate(float): значение интеграла, вычисленное одним из 2-ух способов
        exact(float): значение интеграла, вычисленное через первообразную
    return:
        relative_error(float): относительная погрешность
        absolute_error(float): абсолютная погрешность
    '''
    absolute_error = abs(approximate - exact)
    relative_error = absolute_error / abs(exact) if exact != 0 else float('inf')
    return relative_error, absolute_error

def find_optimal_partitions(method, f, x1, x2, epsilon):
    '''Итерационно ищет кол-во участков, для которых выполняется |I(N)-I(2N)| < epsilon и сам интеграл
    args:
        method(function): любой из 2-ух заданных методов вычисления интеграла
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        epsilon(float): точность эпсилон
    return:
        n(int): кол-во участков
        current_integral: вычисленный интеграл
    '''
    n = 1  # начинаем с минимального N
    prev_integral = method(f, x1, x2, n)
    
    while True:
        n *= 2  
        current_integral = method(f, x1, x2, n)
        
        if abs(current_integral - prev_integral) < epsilon:
            return n, current_integral  
        
        prev_integral = current_integral

try:
    # Проверка корректности данных
    N1 = int(input('Введите кол-во участков разбиения N1: '))
    N2 = int(input('Введите кол-во участков разбиения N2: '))
    x1 = float(input('Введите начало отрезка интегрирования: '))
    x2 = float(input('Введите конец отрезка интегрирования: '))
    epsilon = float(input('Введите точность эпсилон: '))
    
except ValueError:
    print('Введены некорректные входные данные, невозможна дальнейшая работа программы')

else:
    if N1 > 1 and N2 > 1 and epsilon >= 0 and x1 < x2:
        # Значение интеграла, вычисленные 2-мя способами с различными N1, N2
        left_rule_integral1 = left_rule(f,x1,x2,N1)
        left_rule_integral2 = left_rule(f,x1,x2,N2)
        simpsons_rule_integral1 = simpsons_rule(f,x1,x2,N1)
        simpsons_rule_integral2 = simpsons_rule(f,x1,x2,N2)
        
        # Создание таблицы интегралов
        lr1_str = f"{left_rule_integral1:.7g}" if left_rule_integral1 is not None else "---"
        lr2_str = f"{left_rule_integral2:.7g}" if left_rule_integral2 is not None else "---"
        sr1_str = f"{simpsons_rule_integral1:.7g}" if simpsons_rule_integral1 is not None else "---"
        sr2_str = f"{simpsons_rule_integral2:.7g}" if simpsons_rule_integral2 is not None else "---"

        print('-'*94)
        print(f'|{"Интегралы":^30}|{"N1":^30}|{"N2":^30}|')
        print('-'*94)
        print(f'|{"Метод левых прямоугольников":<30}|{lr1_str:^30}|{lr2_str:^30}|')
        print('-'*94)
        print(f'|{"Метод параболы":<30}|{sr1_str:^30}|{sr2_str:^30}|')
        print('-'*94)
        
        # Значение интеграла, вычисленное через первообразное
        exact_value = antiderivative(x1, x2)
        # Если интеграл на заданном интеравале существует
        if (left_rule_integral1 is not None and left_rule_integral2 is not None and \
            simpsons_rule_integral1 is not None and simpsons_rule_integral2 is not None):
            print('Точное значение, вычисленное через формулу Ньютона-Лейбница: ', exact_value)
            relative_error_lr1, absolute_error_lr1 = calculate_errors(left_rule_integral1, exact_value)
            relative_error_lr2, absolute_error_lr2 = calculate_errors(left_rule_integral2, exact_value)
            relative_error_sr1, absolute_error_sr1 = calculate_errors(simpsons_rule_integral1, exact_value)
            relative_error_sr2, absolute_error_sr2 = calculate_errors(simpsons_rule_integral2, exact_value)
            
            # Строится таблица погрешности
            print('-'*94)
            print(f'|{"Погрешности":^30}|{"N1":^30}|{"N2":^30}|')
            print('-'*94)
            print(f'|{"МЛП, относ. погрешность":<30}|{relative_error_lr1:^30.7g}|{relative_error_lr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МЛП, абсолютная погрешность":<30}|{absolute_error_lr1:^30.7g}|{absolute_error_lr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МП, относ. погрешность":<30}|{relative_error_sr1:^30.7g}|{relative_error_sr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МП, абсолютная погрешность":<30}|{absolute_error_sr1:^30.7g}|{absolute_error_sr2:^30.7g}|')
            print('-'*94)
            
            # Сохраняем значения абсолютных погрешностей, чтобы найти наименее точного метода
            absolute_errors = [absolute_error_lr1, absolute_error_lr2, absolute_error_sr1, absolute_error_sr2]
            max_idx = 0

            for i in range(len(absolute_errors)):
                if absolute_errors[i] > absolute_errors[max_idx]:
                    max_idx = i
           
            if max_idx == 0:
                results = find_optimal_partitions(left_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод левых треугольников) - {results[1]}, N = {results[0]}')
            elif max_idx == 1:
                results = find_optimal_partitions(left_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод левых треугольников)- {results[1]}, N = {results[0]}')
            elif max_idx == 2:
                results = find_optimal_partitions(simpsons_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод параболы) - {results[1]}, N = {results[0]}')
            else:
                results = find_optimal_partitions(simpsons_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод параболы)- {results[1]}, N = {results[0]}')
        
            # Находим подходящие промежутки
            intervals = []
            step = 2
            start = -20

            while start < 20:
                a, b = start, start + step
                if h(a) * h(b) < 0:
                    intervals.append((a, b))
                start += step

            # Находим точки пересечения
            roots = []
            for a, b in intervals:
                r = bisection(a, b)
                if r is not None:
                    roots.append(r)
            roots.sort()
            if len(roots) >= 2:
                integral = simpsons_rule(h, roots[0], roots[1], 20)
                print("Точки пересечения:", roots)
                print(f"Интеграл между точками пересечения: {abs(integral)}")
            else:
                print("Не найдено достаточно точек пересечения для вычисления интеграла на данном отрезке")
                integral = None

            if integral:
                y_total_pos = 80
                margin = (roots[1] - roots[0]) * 0.1
                x_min = roots[0] - margin
                x_max = roots[1] + margin
                
                y_min = float('inf')
                y_max = float('-inf')
                x_step = (x_max - x_min) / 50 
                current_x = x_min

                while current_x <= x_max:
                    y1_val = f(current_x)
                    y2_val = g(current_x)
                    y_max = max(y_max, y1_val, y2_val)
                    y_min = min(y_min, y1_val, y2_val)
                    current_x += x_step


                try:
                    notches = int(input('Сколько засечек? '))
                except ValueError:
                    print('Ошибка ввода')

                if 4 <= notches <= 8:
                    last_pos = 0
                    show_y = ' ' * 10
                    y_step = (y_max - y_min) / (notches - 1)
                    
                    for i in range(notches):
                        current_y = y_min + i * y_step
                        normalized_y = (current_y - y_min) / (y_max - y_min)
                        notch_pos = int(normalized_y * (y_total_pos - 1))
                        label = f'{current_y:.2f}'
                        show_y = show_y + ' '*(notch_pos - last_pos) + label
                        last_pos = notch_pos + len(label)

                    print(show_y)
                    print('-' * (y_total_pos + 10))

                    # Отрисовка графика
                    current_x = x_min
                    while current_x <= x_max:
                        y1 = f(current_x)
                        y2 = g(current_x)

                        pos_f = int((y1 - y_min) * (y_total_pos - 1) / (y_max - y_min))
                        pos_g = int((y2 - y_min) * (y_total_pos - 1) / (y_max - y_min))

                        min_pos = min(pos_f, pos_g)
                        max_pos = max(pos_f, pos_g)

                        # Определяем, находимся ли в области пересечения
                        in_intersection = roots[0] <= current_x <= roots[1]

                        x_str = f"{current_x:6.2f} |"
                        graph_line = x_str

                        for pos in range(y_total_pos):
                            if pos == pos_f:
                                graph_line += '*' 
                            elif pos == pos_g:
                                graph_line += '&'  
                            elif in_intersection and min_pos < pos < max_pos:
                                graph_line += '-'  
                            else:
                                graph_line += ' '  

                        print(graph_line)
                        current_x += x_step


                    print('* - график f(x)')
                    print('& - график g(x)')
                    print('- - область пересечения графиков')
 

                else:
                    print('Ошибка, кол-во засечек должно быть от 4 до 8')

            else:
                print('Невозможно построить график, так как интеграл не вычислен')
    else:
            print('N1 и N2, а также эпсилон не могут иметь отрицательные значения')

