# Дао Ань Туан ИУ7-14Б, лаб. 11, метод левых треугольников и параболы 
import math

def f(x):
    '''Считает значение функции
    args:
        x(float): точка '''
    return (x-15)**2 - 100

def g(x):
    return -(x-8)**2 + 100

def h(x):
    return f(x) - g(x)

def bisection(a, b, eps=1e-8):
    fa, fb = h(a), h(b)

    if fa * fb > 0:
        return None

    while b - a > eps:
        c = (a + b) / 2
        fc = h(c)

        if abs(fc) < eps:
            return c

        if fa * fc < 0:
            b = c
            fb = fc
        else:
            a = c
            fa = fc

    return (a + b) / 2

def antiderivative(x1, x2):
    '''Считает значение первообразной
    args:
        x1(float): 1-ая точка
        x2(float): 2-ая точка
    return:
        value(float): значение первообразной
        None(NoneType): если возникает ошибка при вычислении
    '''
    try:
        #value = math.log(x2, math.e) - math.log(x1, math.e)
        value = (1/3 * (x2 - 15)**3 - 100 * x2) - (1/3 * (x1 - 15)**3 - 100 * x1)
        return value
    except (ValueError, ZeroDivisionError):
        print('Ошибка, невозможно вычислить значение первообразной в заданном интервале, интеграл не существует')
        return None

def left_rule(f, x1, x2, n):
    '''Находит интеграл по методу левых треугольников
    args:
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        n(int): кол-во участков разбиения
    return:
        result(float): значение интеграла
        None(NoneType): если интеграл не существует
    '''
    try:
        result = 0
        if n != 0:
            delta_x = (x2 - x1) / n
            for i in range(n):
                y = f(x1 + i * delta_x)
                # слишком большая величина => разрыв / асимптота
                if not math.isfinite(y):
                    return None
                result += y * delta_x
                
        return result
        
    except (ZeroDivisionError, ValueError, OverflowError):
        return None

def simpsons_rule(f, x1, x2, n):
    '''Находит интеграл по методу парабол
    args:
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        n(int): кол-во участков разбиения
    return:
        result(float): значение интеграла
        None(NoneType): если интеграл не существует
    '''
    try:
        result = 0
        if n != 0:
            delta_x = (x2 - x1) / n
            for i in range(n):
                y1 = f(x1 + i * delta_x)
                y2 = f(x1 + (i + 0.5) * delta_x)
                y3 = f(x1 + (i + 1) * delta_x)

                if not (math.isfinite(y1) and math.isfinite(y2) and math.isfinite(y3)):
                    return None
                result += (y1 + 4 * y2 + y3) * delta_x / 6
                
        return result
        
    except (ZeroDivisionError, ValueError, OverflowError):
        return None

def calculate_errors(approximate, exact):
    '''Вычисление абсолютной и относительной погрешностей
    args:
        approximate(float): значение интеграла, вычисленное одним из 2-ух способов
        exact(float): значение интеграла, вычисленное через первообразную
    return:
        relative_error(float): относительная погрешность
        absolute_error(float): абсолютная погрешность
    '''
    absolute_error = abs(approximate - exact)
    relative_error = absolute_error / abs(exact) if exact != 0 else float('inf')
    return relative_error, absolute_error

def find_optimal_partitions(method, f, x1, x2, epsilon):
    '''Итерационно ищет кол-во участков, для которых выполняется |I(N)-I(2N)| < epsilon и сам интеграл
    args:
        method(function): любой из 2-ух заданных методов вычисления интеграла
        f(function): вычисляет значение функции
        x1(float): 1-ая точка
        x2(float): 2-ая точка
        epsilon(float): точность эпсилон
    return:
        n(int): кол-во участков
        current_integral: вычисленный интеграл
    '''
    n = 4  # начинаем с минимального N
    prev_integral = method(f, x1, x2, n)
    
    while True:
        n *= 2  
        current_integral = method(f, x1, x2, n)
        
        if abs(current_integral - prev_integral) < epsilon:
            return n, current_integral  
        
        prev_integral = current_integral

try:
    # Проверка корректности данных
    N1 = int(input('Введите кол-во участков разбиения N1: '))
    N2 = int(input('Введите кол-во участков разбиения N2: '))
    x1 = float(input('Введите начало отрезка интегрирования: '))
    x2 = float(input('Введите конец отрезка интегрирования: '))
    epsilon = float(input('Введите точность эпсилон: '))
    
except ValueError:
    print('Введены некорректные входные данные, невозможна дальнейшая работа программы')

else:
    if N1 > 1 and N2 > 1 and epsilon >= 0 and x1 < x2:
        # Значение интеграла, вычисленные 2-мя способами с различными N1, N2
        left_rule_integral1 = left_rule(f,x1,x2,N1)
        left_rule_integral2 = left_rule(f,x1,x2,N2)
        simpsons_rule_integral1 = simpsons_rule(f,x1,x2,N1)
        simpsons_rule_integral2 = simpsons_rule(f,x1,x2,N2)
        
        # Создание таблицы интегралов
        lr1_str = f"{left_rule_integral1:.7g}" if left_rule_integral1 is not None else "---"
        lr2_str = f"{left_rule_integral2:.7g}" if left_rule_integral2 is not None else "---"
        sr1_str = f"{simpsons_rule_integral1:.7g}" if simpsons_rule_integral1 is not None else "---"
        sr2_str = f"{simpsons_rule_integral2:.7g}" if simpsons_rule_integral2 is not None else "---"

        print('-'*94)
        print(f'|{"Интегралы":^30}|{"N1":^30}|{"N2":^30}|')
        print('-'*94)
        print(f'|{"Метод левых прямоугольников":<30}|{lr1_str:^30}|{lr2_str:^30}|')
        print('-'*94)
        print(f'|{"Метод параболы":<30}|{sr1_str:^30}|{sr2_str:^30}|')
        print('-'*94)
        
        # Значение интеграла, вычисленное через первообразное
        exact_value = antiderivative(x1, x2)
        # Если интеграл на заданном интеравале существует
        if (left_rule_integral1 is not None and left_rule_integral2 is not None and \
            simpsons_rule_integral1 is not None and simpsons_rule_integral2 is not None):
            print('Точное значение, вычисленное через формулу Ньютона-Лейбница: ', exact_value)
            relative_error_lr1, absolute_error_lr1 = calculate_errors(left_rule_integral1, exact_value)
            relative_error_lr2, absolute_error_lr2 = calculate_errors(left_rule_integral2, exact_value)
            relative_error_sr1, absolute_error_sr1 = calculate_errors(simpsons_rule_integral1, exact_value)
            relative_error_sr2, absolute_error_sr2 = calculate_errors(simpsons_rule_integral2, exact_value)
            
            # Строится таблица погрешности
            print('-'*94)
            print(f'|{"Погрешности":^30}|{"N1":^30}|{"N2":^30}|')
            print('-'*94)
            print(f'|{"МЛП, относ. погрешность":<30}|{relative_error_lr1:^30.7g}|{relative_error_lr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МЛП, абсолютная погрешность":<30}|{absolute_error_lr1:^30.7g}|{absolute_error_lr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МП, относ. погрешность":<30}|{relative_error_sr1:^30.7g}|{relative_error_sr2:^30.7g}|')
            print('-'*94)
            print(f'|{"МП, абсолютная погрешность":<30}|{absolute_error_sr1:^30.7g}|{absolute_error_sr2:^30.7g}|')
            print('-'*94)
            
            # Сохраняем значения абсолютных погрешностей, чтобы найти наименее точного метода
            absolute_errors = [absolute_error_lr1, absolute_error_lr2, absolute_error_sr1, absolute_error_sr2]
            max_idx = 0

            for i in range(len(absolute_errors)):
                if absolute_errors[i] > absolute_errors[max_idx]:
                    max_idx = i
           
            if max_idx == 0:
                results = find_optimal_partitions(left_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод левых треугольников) - {results[1]}, N = {results[0]}')
            elif max_idx == 1:
                results = find_optimal_partitions(left_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод левых треугольников)- {results[1]}, N = {results[0]}')
            elif max_idx == 2:
                results = find_optimal_partitions(simpsons_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод параболы) - {results[1]}, N = {results[0]}')
            else:
                results = find_optimal_partitions(simpsons_rule, f, x1, x2, epsilon)
                print(f'Приближенное значение интеграла, для функции с наименьшей точностью (метод параболы)- {results[1]}, N = {results[0]}')
        
            # Находим подходящие промежутки
            intervals = []
            step = 2
            start = -20

            while start < 20:
                a, b = start, start + step
                if h(a) * h(b) < 0:
                    intervals.append((a, b))
                start += step

            # Находим точки пересечения
            roots = []
            for a, b in intervals:
                r = bisection(a, b)
                if r is not None:
                    roots.append(r)

            if len(roots) >= 2:
                integral = simpsons_rule(h, roots[0], roots[1], 20)
                print("Точки пересечения:", roots)
                print(f"Интеграл между точками пересечения: {integral}")
            else:
                print("Не найдено достаточно точек пересечения для вычисления интеграла")
                integral = None

            y_total_pos = 80
            x_min = -20
            x_max = 20
            y_min = float('inf')
            y_max = float('-inf')
            y2_max = float('-inf')
            x_step = 2

            notches = int(input('Сколько засечек? '))
            last_pos = 0
            show_y = ' ' * 10

            if 4 <= notches <= 8:
                # Находим y_min и y_max перед построением графика
                current_x = x_min
                n = int((x_max - x_min) / x_step)

                for i in range(n + 1):
                    y_val = f(current_x)
                    y2_val = g(current_x)
                    y_max = max(y_max, y_val, y2_val)
                    y_min = min(y_min, y_val, y2_val)
                    current_x += x_step


                y_step = (y_max - y_min) / (notches - 1)
                for i in range(notches):
                    current_y = y_min + i * y_step
                    #Масштабируем
                    normalized_y = (current_y - y_min) / (y_max - y_min)
                    notch_pos = int(normalized_y * (y_total_pos - 1))
                    #Вывод значения
                    label = f'{current_y:.4g}'
                    show_y = show_y + ' '*(notch_pos - last_pos) + label
                    last_pos = notch_pos + len(label)  # учитываем длину подписи

                print(show_y)
                print()

            current_x = x_min
            n = int((x_max - x_min) / x_step)

            for i in range(n + 1):
                y1 = f(current_x)
                y2 = g(current_x)

                pos_f = int((y1 - y_min) * (y_total_pos - 1) / (y_max - y_min))
                pos_g = int((y2 - y_min) * (y_total_pos - 1) / (y_max - y_min))

                min_pos = min(pos_f, pos_g)
                max_pos = max(pos_f, pos_g)

                inside = roots[0] <= current_x <= roots[1]

                x_str = f"{current_x:4} |"
                graph_line = x_str

                for pos in range(y_total_pos):
                    if pos == pos_f:
                        graph_line += "*"
                    elif pos == pos_g:
                        graph_line += "&"
                    elif inside and min_pos < pos < max_pos:
                        graph_line += "-"    
                    else:
                        graph_line += " "

                print(graph_line)
                current_x += x_step

            else:
                print('Ошибка, кол-во засечек не должно превышать 8 и быть меньше 4')
                print('Максимальное значение y не должно совпадать с минимальным значением y, оба значение не должны быть отрицательными')

        else:
            print('Невозможно посчитать погрешность, так как функция не интегрируема')
    else:
        print('N1 и N2, а также эпсилон не могут иметь отрицательные значения')

